
import _ from 'lodash';
import moment from 'moment';

// Groups sections of the same class and type into a single sets, returns all unique sets generated
export const generateSets = (courses) => {
    var sets = [];
    for (const course of courses) {
        const sections = _.filter(course.sections, section => section.timeslots.length > 0);
        const sectionGroups = _.groupBy(sections, section => section.kind);
        const courseSets = Object.values(sectionGroups);
        sets = sets.concat(courseSets);
    }
    return sets;
};

// Returns the cartesian product of the provided sets, i.e. returns all combinations generated by picking one item from each set
export const cartesianProduct = (sets, n = 0, result = [], current = []) => {
    if (n === sets.length) result.push(current)
    else sets[n].forEach(item => cartesianProduct(sets, n + 1, result, [...current, item]))

    return result
};


const weekdays = ['Mo', 'Tu', 'We', 'Th', 'Fr'];
// Flattens timeslots and checks for any conflicts
export const generateTimetables = (combinations) => {
    var timetables = [];
    for (const combination of combinations) {
        const classes = _.flatMap(combination, set => ({ courseCode: set.course_code, kind: set.kind, code: set.code }));
        const timeslots = _.flatMap(combination, set => set.timeslots)
        var days = _.groupBy(timeslots, timeslot => timeslot.day)
        var valid = true;
        for (const weekday of weekdays) {
            days[weekday] = _.sortBy(days[weekday], 'start_time');
            valid = valid && validateDay(days[weekday]);
            if (!valid) { break; };
        }
        if (valid) {
            timetables.push({
                classes,
                days
            });
        };
    }
    return timetables;
};

export const generateScores = (timetables, lunchTime, dinnerTime, scoreRatio) => {
    const lunchTimeslot = { start_time: lunchTime[0].format('hh:mm'), end_time: lunchTime[1].format('hh:mm') };
    const dinnerTimeslot = { start_time: dinnerTime[0].format('hh:mm'), end_time: dinnerTime[1].format('hh:mm') };
    console.log(lunchTimeslot);
    const mealRatio = 2 * ((10 - scoreRatio) / 10);
    const timeRatio = 2 * (scoreRatio / 10);
    return timetables.map((timetable) => {
        const scores = { total: 0, lunch: 0, dinner: 0, offTime: 0, type: "late" }
        for (const day of Object.values(timetable['days'])) {
            scores['offTime'] += calculateOfftime(day);
            scores['lunch'] += checkAvailability(day, lunchTimeslot) ? 1 : 0;
            scores['dinner'] += checkAvailability(day, dinnerTimeslot) ? 1 : 0;
        }
        scores['type'] = calculateTimeType(timetable['days']);
        scores['total'] = 10 - (5 - scores['lunch']) * mealRatio - (5 - scores['dinner']) * mealRatio - Math.round(scores['offTime'] * timeRatio);
        return {
            classes: timetable['classes'],
            timetable: timetable['days'],
            scores
        }
    })
}

const validateDay = (day) => {
    if (day.length === 0 || day.length === 1) {
        return true;
    }
    for (var i = 1; i < day.length; i++) {
        const prevTime = day[i - 1];
        const currTime = day[i];
        if (currTime.start_time < prevTime.end_time) {
            return false;
        }
    }
    return true;
}

const calculateTimeType = (timetable) => {
    const types = { 'Early': 0, 'Mid-Day': 0, 'Late': 0 };
    for (const day of Object.values(timetable)) {
        for (const timeslot of day) {
            if (timeslot.start_time < "10:30") {
                types['Early']++;
            } else if (timeslot.start_time < "3:30") {
                types['Mid-Day']++;
            } else {
                types['Late']++;
            }
        }
    }
    const max = Object.entries(types).reduce((a, b) => a[1] > b[1] ? a : b)[0];
    return max;
}

const calculateOfftime = (day) => {
    if (day.length === 0 || day.length === 1) {
        return 0;
    }
    var sum = 0;
    for (var i = 1; i < day.length; i++) {
        const prevTime = day[i - 1];
        const currTime = day[i];
        const prevMoment = moment(prevTime.end_time, moment.HTML5_FMT.TIME);
        const currMoment = moment(currTime.start_time, moment.HTML5_FMT.TIME);
        const duration = moment.duration(currMoment.diff(prevMoment));
        const hours = duration.asHours();
        sum += hours;
    }
    return sum;
}

const checkAvailability = (day, target) => {
    if (day.length === 0) {
        return true;
    }

    if (day.length === 1) {
        return !(target.end_time > day[0].start_time && day[0].end_time > target.start_time)
    }

    var left = 0;
    var right = day.length - 1;
    var mid;
    while (true) {
        mid = Math.floor((right + left) / 2);
        if (day[mid].end_time === target.start_time) {
            mid++;
            break;
        }
        if (day[mid].end_time > target.start_time) {
            right = mid - 1;
            if (left > right) {
                break;
            }
        } else {
            left = mid + 1;
            if (left > right) {
                mid++;
                break;
            }
        }
    }

    if (mid === day.length) { return true };
    return target.end_time <= day[mid].start_time
}